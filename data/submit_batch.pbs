#PBS -l walltime=03:00:00
#PBS -l select=1:ncpus=8:mem=16gb
#PBS -J 0-71

# Define parameter arrays
# MP values between 0.1 and 0.8 (e.g., 0.1, 0.3, 0.5, 0.7)
mp_values=(0.1 0.3 0.5 )
# DR values between 0.1 and 0.8 (e.g., 0.1, 0.3, 0.5, 0.7)
dr_values=(0.1 0.3 )
# Transformer layers: 2 or 4
tl_values=(2 4)
# Attention heads: 8 or 16
at_values=(8 16 32)
# d_model values: 32, 64, 128
d_model_values=(64 128)

# Calculate total number of values for each parameter
total_mp_values=${#mp_values[@]}
total_dr_values=${#dr_values[@]}
total_tl_values=${#tl_values[@]}
total_at_values=${#at_values[@]}
total_d_model_values=${#d_model_values[@]}

# Calculate indices for each parameter
# We need to distribute the PBS_ARRAY_INDEX across all parameters.
# The order of division and modulo matters to ensure all combinations are covered.
# Let's say d_model varies fastest, then at, then tl, then dr, then mp.

d_model_index=$((${PBS_ARRAY_INDEX} % total_d_model_values))
temp_index=$(( ${PBS_ARRAY_INDEX} / total_d_model_values ))

at_index=$((${temp_index} % total_at_values))
temp_index=$(( ${temp_index} / total_at_values ))

tl_index=$((${temp_index} % total_tl_values))
temp_index=$(( ${temp_index} / total_tl_values ))

dr_index=$((${temp_index} % total_dr_values))
mp_index=$(( ${temp_index} / total_dr_values ))

# Assign values to variables
mp=${mp_values[$mp_index]}
dr=${dr_values[$dr_index]}
tl=${tl_values[$tl_index]}
at=${at_values[$at_index]}
d_model=${d_model_values[$d_model_index]}

# Check d_model divisibility by at
if (( d_model % at != 0 )); then
    echo "Skipping combination: d_model ($d_model) is not divisible by at ($at)"
    exit 0 # Exit successfully if not divisible, so PBS doesn't mark it as failed
fi

module load anaconda3/personal
source activate ddfp
cd $PBS_O_WORKDIR

python train_model.py -num_epochs 300 -td shuffle_train_cat.csv -vd shuffle_test_cat.csv -mp "${mp}" -dr "${dr}" -tl "${tl}" -at "${at}" -d_model "${d_model}"
